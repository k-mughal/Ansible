# Variables
- Variables in Ansible function similarly to those in other programming languages and tools, such as Bash, Python, and Jenkins. Much like in these contexts, Ansible allows you to define your own variables. You can utilize pre-existing variables within Ansible or generate new ones during runtime. The process of defining variables in an Ansible playbook is straightforward, mirroring the practices found in various programming languages and tools.

```
PLAYBOOK:
- host: websrvgrp
  vars:
     http_port: 80
     sqluser: admin
```

- If you desire specific variables for a particular group, such as a website, or if you want to define variables for a specific host, you can do so by creating group_vars/group_name or host_vars/hostname files. The group name corresponds to the one defined in the inventory file. For host-specific variables, use the hostname as the filename within the host_vars directory. This approach allows you to define variables outside of your playbook.
  - Inventory Based
  - In Inventory file
  - group_vars/all
  - group_vars/groupname
  - host_var/hostname

- Next, Ansible introduces roles, which we'll explore in more detail later. Additionally, there are two files where you can define variables: vars and defaults.
    - Roles
      - Include variables from files in playbook
# Fact Variables: setup module
<p align="center">
  <img src="https://github.com/k-mughal/Ansible/assets/18217530/da21ebea-5a21-41f8-9331-83a091b9a350">
</p>


- Ansible comes with its own set of variables, with a significant portion being generated by the setup module. You don't need to explicitly run the setup module; it runs automatically during the playbook's first task, "gathering facts," and generates various fact variables.

- For instance, when running on a host like "web01," you'll have variables like `ansible_os_family` indicating the operating system family (e.g., Red Hat, Debian), `ansible_processor_cores` specifying the number of CPU cores, and `ansible_kernel` providing the kernel version. There are numerous other fact variables, including details about connected devices, default IPv4 information, MAC address, gateway IP, and architecture (64-bit or 32-bit).

- These fact variables, automatically generated through the setup module, can be utilized in playbooks for tasks such as configuring files or making decisions based on host characteristics (e.g., installing different packages for 64-bit and 32-bit systems). They enable dynamic decision-making in playbooks through conditions and provide valuable host-related information.

- This set of automatically generated variables is commonly referred to as "fact variables" and is an integral part of Ansible's functionality. Another way to introduce variables is by storing the output of a task, offering flexibility in playbook design.
  
<p align="center">
  <img src="https://github.com/k-mughal/Ansible/assets/18217530/60b90f0e-b545-463b-b4ef-3500353d1ba9">
</p>

- Another approach is to store the output of a task. When executing a task or any module that returns output in JSON format, we can capture that output and assign it to a variable using the `register` option. This variable becomes a runtime variable, preserved for a specific purpose. The stored output might be crucial for decision-making or used in subsequent tasks. 

- By creating and storing custom variables in the playbook, group vars, host vars, or roles, and also leveraging runtime variables generated through the setup module's gathering facts task, along with those captured from task outputs, Ansible provides a robust system for managing and utilizing variables dynamically within playbooks.
- We'll commence with straightforward examples. Open the playbook, and within it, we'll define some variables to use. Emphasis is placed on "in" because although it's not ideal, we'll initially explore how to define variables within the playbook. Subsequently, we'll delve into the more advantageous practice of defining variables outside the playbook. 
 
```
cp - r exercise7 exercise8
cd exercise8 
vim db.yaml
---
- name: DBserver Setup
  hosts: dbservers
  become: yes
  vars:
    dbname: electric
    dbuser: current
    dbpass: tesla

  tasks:
    - name: Install mariadb-server
      ansible.builtin.yum:
        name: mariadb-server
        state: present

    - name: install pymysql
      ansible.builtin.yum:
        name: python3-PyMySQL
        state: present

    - name: Start mariadb service
      ansible.builtin.service:
        name: mariadb
        state: started
        enabled: yes

    - name: Create a new database with name 'accounts'
      community.mysql.mysql_db:
        name: "{{dbname}}"
        state: present
        login_unix_socket: /var/lib/mysql/mysql.sock

    - name: Create database user with name 'premiumUser'
      community.mysql.mysql_user:
        name: "{{dbuser}}"
        password: "{{dbpass}}"
        priv: '*.*:ALL'
        state: present
        login_unix_socket: /var/lib/mysql/mysql.sock

:wq

ansible-playbook db.yaml

```

- For debugging purposes, we can incorporate the following task to observe the variable output.
  
<p align="center">
  <img src="https://github.com/k-mughal/Ansible/assets/18217530/2e34a916-efde-4609-a01f-4c0c992772b8">
</p>
<p align="center">
  <img src="https://github.com/k-mughal/Ansible/assets/18217530/b4ed56f0-38f5-4c20-85d4-8257ccd6715b">
</p>

- When a module executes and produces output, it is usually suppressed by default. When we run the playbook, the output is presented in JSON format, and we can capture this output using a variable. "register module" capture the output and using the debug module prints the output. Most this technique is use for troubleshooting purpose only. The method to achieve this is outlined below.
  
 <p align="center">
  <img src="https://github.com/k-mughal/Ansible/assets/18217530/6a790d44-8a4b-4eb8-9c4c-244f968dc086">
</p> 

 <p align="center">
  <img src="https://github.com/k-mughal/Ansible/assets/18217530/319c8db4-db12-4875-a503-ac841ec210d8">
</p>



  
 
